<application>
  <component name="AppStorage">
    <histories>
      <item value="contained" />
      <item value="The number of key-value mappings contained in this map" />
      <item value="The load factor used when none specified in constructor" />
      <item value="this field holds the initial array capacity, or zero signifying" />
      <item value="Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4" />
        <entry key="ENGLISH" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1611463554229" />
  </component>
</application>